package com.dummy.wmd.wpc.graphql.model;

import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DatabindContext;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.jsontype.BasicPolymorphicTypeValidator;
import com.fasterxml.jackson.databind.jsontype.PolymorphicTypeValidator;
import com.fasterxml.jackson.databind.jsontype.impl.ClassNameIdResolver;
import com.fasterxml.jackson.databind.type.SimpleType;
import com.fasterxml.jackson.databind.type.TypeFactory;
import com.dummy.wmd.wpc.graphql.utils.ObjectMapperUtils;
import lombok.Data;

import java.io.IOException;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Stream;

@Data
public class BatchJobExecutionStep {
    private String shortContext;
    private Long jobExecutionId;
    private String stepName;
    private Date startTime;
    private String status;
    private String commitCount;
    private String readCount;
    private String filterCount;
    private String writeCount;
    private String readSkipCount;
    private String writeSkipCount;
    private String processSkipCount;
    private String rollbackCount;
    private String exitCode;
    private String exitMessage;
    private String serializedContext;


    public void setShortContext(String shortContext) {
        if (Objects.nonNull(shortContext)) {
            try {
                this.shortContext = ObjectMapperUtils.writeValueAsString(objectMapper.readValue(shortContext, Object.class));
            } catch (JsonProcessingException e) {
                this.shortContext = shortContext;
            }
        }
    }

    public void setSerializedContext(String serializedContext) {
        if (Objects.nonNull(serializedContext)) {
            try {
                this.serializedContext = ObjectMapperUtils.writeValueAsString(objectMapper.readValue(serializedContext, Object.class));
            } catch (JsonProcessingException e) {
                this.serializedContext = serializedContext;
            }
        }
    }

    static final ObjectMapper objectMapper = new ObjectMapper();

    static {
        PolymorphicTypeValidator polymorphicTypeValidator = BasicPolymorphicTypeValidator.builder()
                .allowIfSubType(Object.class)
                .build();
        ObjectMapper.DefaultTypeResolverBuilder defaultTypeResolverBuilder = new ObjectMapper.DefaultTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL, polymorphicTypeValidator);
        SimpleClassIdResolver simpleClassIdResolver = new SimpleClassIdResolver(objectMapper.getTypeFactory(), polymorphicTypeValidator);
        defaultTypeResolverBuilder.init(JsonTypeInfo.Id.CLASS, simpleClassIdResolver);
        defaultTypeResolverBuilder.inclusion(JsonTypeInfo.As.PROPERTY);
        objectMapper.setDefaultTyping(defaultTypeResolverBuilder);
    }

    /**
     * The short context is generated by spring batch framework and has @class information.
     * We don't want to show it in ui so this class is used to remove it.
     * <br>
     *
     * Example:
     * <pre>
    {
      "updatedFailedProducts": [
        "java.util.Collections$SynchronizedList",
        [
          {
            "@class": "com.dummy.wpb.product.model.graphql.InvalidProduct",
            "product": {
              "@class": "org.bson.Document",
              "ctryRecCde": "HK",
              "grpMembrRecCde": "HBAP",
              "prodTypeCde": "UT",
              "prodAltPrimNum": "U62447"
            },
            "errors": [
              "java.util.ArrayList",
              [
                {
                  "@class": "com.dummy.wpb.product.model.graphql.InvalidProductError",
                  "jsonPath": "tradeCcy[1].ccyProdTradeCde",
                  "code": "tradeCcy[*].ccyProdTradeCde@referenceData",
                  "message": "Reference data doesn't exist: {cdvTypeCde=BASECCY, cdvCde=USD11}"
                }
              ]
            ]
          }
        ]
      ]
    }
     * </pre>
     */
    static class SimpleClassIdResolver extends ClassNameIdResolver {
        public SimpleClassIdResolver(TypeFactory typeFactory, PolymorphicTypeValidator ptv) {
            super(SimpleType.constructUnsafe(Object.class), typeFactory, ptv);
        }

        @Override
        public JavaType typeFromId(DatabindContext context, String id) throws IOException {
            Class<?> cls;
            try {
                cls = Class.forName(id);
            } catch (ClassNotFoundException e) {
                return super.typeFromId(context, "java.util.LinkedHashMap");
            }

            if (isContainer(cls)) {
                return super.typeFromId(context, "java.util.ArrayList");
            } else if (!cls.isPrimitive()) {
                return super.typeFromId(context, "java.util.LinkedHashMap");
            }

            return super.typeFromId(context, id);
        }

        private boolean isContainer(Class<?> cls) {
            return cls.isArray() || (Stream.of(cls.getInterfaces()).anyMatch(item -> item == List.class || item == Set.class));
        }
    }
}
